<!DOCTYPE html>
<html lang="nl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Woordenschat Oefening - Thema 2</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', 'Segoe UI', -apple-system, BlinkMacSystemFont, sans-serif;
            background: #e8f4f8;
            min-height: 100vh;
            padding: 20px;
            color: #2c3e50;
        }

        .container {
            max-width: 900px;
            margin: 0 auto;
        }

        header {
            background: white;
            padding: 30px;
            border-radius: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            margin-bottom: 30px;
            text-align: center;
            position: sticky;
            top: 0;
            z-index: 1000;
            transition: padding 0.25s ease, box-shadow 0.25s ease, border-radius 0.25s ease;
        }

        header.compact {
            padding: 12px 16px;
            border-radius: 16px;
            box-shadow: 0 6px 18px rgba(0,0,0,0.18);
        }

        .header-top {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
        }

        header.compact .header-top h1 {
            font-size: 1.1em;
            color: #547aa5;
        }

        .header-body {
            transition: opacity 0.2s ease, max-height 0.2s ease;
        }

        header.compact .header-body {
            opacity: 0;
            max-height: 0;
            overflow: hidden;
        }

        .compact-row {
            display: none;
            align-items: center;
            gap: 12px;
        }

        header.compact .compact-row {
            display: flex;
        }

        .compact-stats {
            flex: 1;
            display: flex;
            justify-content: center;
            gap: 16px;
            color: #2c3e50;
            font-weight: 600;
            white-space: nowrap;
        }

        .compact-stats .stat-pending {
            color: #7ba3d4;
        }

        /* Shrink Start button in compact */
        header.compact .start-btn {
            padding: 10px 16px;
            font-size: 0.9em;
        }

        /* Make timer more prominent in compact */
        header.compact #timer-display {
            font-size: 1.6em !important;
            margin: 0 !important;
        }

        /* Mobile: prioritize pending; hide correct/incorrect in very narrow widths */
        @media (max-width: 420px) {
            .compact-stats .stat-correct,
            .compact-stats .stat-incorrect {
                display: none;
            }
        }

        h1 {
            color: #7ba3d4;
            font-size: 1.8em;
            margin-bottom: 10px;
            font-weight: 600;
        }

        .score-board {
            display: flex;
            justify-content: center;
            gap: 30px;
            margin-top: 20px;
            font-size: 1em;
        }

        .score-item {
            padding: 10px 20px;
            background: #f8fbfd;
            border-radius: 10px;
            font-weight: 600;
            border: 2px solid #e8f4f8;
        }

        .correct { color: #4CAF50; }
        .incorrect { color: #f44336; }

        .theme-selector {
            display: grid;
            grid-template-columns: repeat(4, minmax(0, 1fr));
            gap: 12px;
            margin-bottom: 20px;
        }

        .theme-select-wrapper {
            grid-column: 1 / -1;
            display: flex;
            justify-content: center;
        }

        .theme-select {
            width: 100%;
            max-width: 500px;
            padding: 14px 16px;
            border-radius: 14px;
            border: 2px solid #cfe0ee;
            font-size: 1em;
            font-family: 'Inter', 'Segoe UI', -apple-system, BlinkMacSystemFont, sans-serif;
            color: #2c3e50;
            background: white;
            box-shadow: 0 5px 15px rgba(0,0,0,0.08);
        }

        .theme-select:focus {
            outline: none;
            border-color: #7ba3d4;
            box-shadow: 0 0 0 3px rgba(123, 163, 212, 0.2);
        }

        .theme-btn {
            padding: 12px 8px;
            font-size: 0.9em;
            border: none;
            border-radius: 15px;
            cursor: pointer;
            background: white;
            color: #7ba3d4;
            font-weight: 500;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
            transition: all 0.3s;
            font-family: 'Inter', 'Segoe UI', -apple-system, BlinkMacSystemFont, sans-serif;
        }

        .theme-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 20px rgba(123, 163, 212, 0.3);
        }

        .theme-btn.active {
            background: #7ba3d4;
            color: white;
        }

        .exercise-type-selector {
            display: grid;
            grid-template-columns: repeat(4, minmax(0, 1fr));
            gap: 12px;
            margin-bottom: 30px;
        }

        .exercise-type-btn {
            padding: 14px 10px;
            border: none;
            border-radius: 15px;
            cursor: pointer;
            background: white;
            color: #c9a5d4;
            font-weight: 600;
            font-size: 1em;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
            transition: all 0.3s;
            font-family: 'Inter', 'Segoe UI', -apple-system, BlinkMacSystemFont, sans-serif;
        }

        .exercise-type-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 8px 20px rgba(201, 165, 212, 0.3);
        }

        .exercise-type-btn.active {
            background: #c9a5d4;
            color: white;
        }

        @media (max-width: 900px) {
            .theme-btn,
            .exercise-type-btn {
                font-size: 0.85em;
            }
        }

        @media (max-width: 600px) {
            .theme-selector,
            .exercise-type-selector {
                grid-template-columns: repeat(4, minmax(60px, 1fr));
            }

            .theme-btn,
            .exercise-type-btn {
                padding: 10px 6px;
                font-size: 0.75em;
            }
        }

        .card {
            background: white;
            padding: 40px;
            border-radius: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.15);
            margin-bottom: 20px;
            animation: slideIn 0.5s ease;
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .question {
            font-size: 1.2em;
            margin-bottom: 30px;
            color: #2c3e50;
            line-height: 1.6;
            font-weight: 500;
        }

        .options {
            display: grid;
            gap: 15px;
        }

        .option-btn {
            padding: 20px;
            font-size: 1em;
            border: 3px solid #e0e0e0;
            border-radius: 15px;
            background: white;
            cursor: pointer;
            transition: all 0.3s;
            text-align: left;
            font-weight: 500;
            font-family: 'Inter', 'Segoe UI', -apple-system, BlinkMacSystemFont, sans-serif;
        }

        .option-btn:hover {
            border-color: #7ba3d4;
            background: #f8fbfd;
        }

        .option-btn.correct {
            background: #4CAF50;
            color: white;
            border-color: #4CAF50;
        }

        .option-btn.incorrect {
            background: #f44336;
            color: white;
            border-color: #f44336;
        }

        .option-btn.disabled {
            cursor: not-allowed;
            opacity: 0.7;
        }

        .input-answer {
            width: 100%;
            padding: 20px;
            font-size: 1em;
            border: 3px solid #e0e0e0;
            border-radius: 15px;
            margin-bottom: 20px;
            font-family: 'Inter', 'Segoe UI', -apple-system, BlinkMacSystemFont, sans-serif;
        }

        .input-answer:focus {
            outline: none;
            border-color: #7ba3d4;
            box-shadow: 0 0 0 3px rgba(123, 163, 212, 0.1);
        }

        .submit-btn {
            padding: 15px 40px;
            font-size: 1em;
            border: none;
            border-radius: 15px;
            background: #7ba3d4;
            color: white;
            cursor: pointer;
            font-weight: 500;
            box-shadow: 0 5px 15px rgba(123, 163, 212, 0.3);
            transition: all 0.3s;
            font-family: 'Inter', 'Segoe UI', -apple-system, BlinkMacSystemFont, sans-serif;
        }

        .submit-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 7px 20px rgba(123, 163, 212, 0.4);
            background: #6a92c3;
        }

        .next-btn-wrapper {
            width: 100%;
            display: flex;
            justify-content: flex-end;
        }

        .next-btn {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            margin-top: 16px;
            padding: 12px 24px;
            font-size: 0.95em;
            border: none;
            border-radius: 999px;
            background: #4CAF50;
            color: white;
            cursor: pointer;
            font-weight: 600;
            box-shadow: 0 6px 20px rgba(76, 175, 80, 0.25);
            transition: background 0.2s ease, transform 0.2s ease;
            font-family: 'Inter', 'Segoe UI', -apple-system, BlinkMacSystemFont, sans-serif;
        }

        .next-btn:hover {
            background: #3d9b41;
            transform: translateX(3px);
        }

        .feedback {
            margin-top: 16px;
            font-size: 1em;
            font-weight: 600;
            text-align: left;
            color: #2c3e50;
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .feedback.correct {
            color: #2e7d32;
        }

        .feedback.incorrect {
            color: #c62828;
        }

        /* Language switcher (floating) */
        .lang-switcher {
            position: fixed;
            right: 12px;
            bottom: 12px;
            display: flex;
            gap: 8px;
            background: #ffffff;
            padding: 6px 8px;
            border-radius: 999px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.15);
            border: 2px solid #e8f4f8;
            z-index: 12000;
        }

        .lang-btn {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            border: 2px solid #cfe0ee;
            background: #fff;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
            padding: 0;
            transition: transform 0.15s ease, box-shadow 0.15s ease, border-color 0.15s ease;
        }

        .lang-btn img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            border-radius: 50%;
            display: block;
        }

        .lang-btn:hover { transform: translateY(-2px); }

        .lang-btn.active {
            border-color: #7ba3d4;
            box-shadow: 0 0 0 3px rgba(123, 163, 212, 0.2);
        }

        @media (max-width: 480px) {
            .lang-switcher { right: 8px; bottom: 8px; padding: 4px; gap: 6px; }
            .lang-btn { width: 32px; height: 32px; }
        }

        .matching-container {
            display: flex;
            flex-wrap: nowrap;
            gap: 24px;
            overflow-x: auto;
            padding-bottom: 10px;
        }

        .matching-column {
            display: flex;
            flex-direction: column;
            gap: 10px;
            min-width: clamp(220px, 45vw, 360px);
        }

        .matching-item {
            padding: 15px;
            background: #f5f5f5;
            border: 3px solid #e0e0e0;
            border-radius: 10px;
            cursor: pointer;
            display: flex;
            align-items: center;
            line-height: 1.35;
            word-break: break-word;
            min-height: 52px;
            transition: background 0.2s ease, border-color 0.2s ease, color 0.2s ease;
        }

        .matching-item:hover {
            border-color: #7ba3d4;
            background: #f8fbfd;
        }

        .matching-item.selected {
            background: #7ba3d4;
            color: white;
            border-color: #7ba3d4;
        }

        .matching-item.matched {
            background: #4CAF50;
            color: white;
            border-color: #4CAF50;
            cursor: default;
        }

        .matching-item.incorrect {
            background: #f44336;
            color: white;
            border-color: #f44336;
        }

        .true-false-btns {
            display: flex;
            gap: 12px;
            justify-content: flex-end;
            flex-wrap: wrap;
        }

        .tf-btn {
            padding: 12px 24px;
            font-size: 0.95em;
            border: none;
            border-radius: 999px;
            cursor: pointer;
            font-weight: 600;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            transition: all 0.2s;
            font-family: 'Inter', 'Segoe UI', -apple-system, BlinkMacSystemFont, sans-serif;
        }

        .tf-btn.true {
            background: #4CAF50;
            color: white;
        }

        .tf-btn.false {
            background: #f44336;
            color: white;
        }

        .tf-btn:hover {
            transform: scale(1.1);
        }

        @media (max-width: 768px) {
            h1 {
                font-size: 1.5em;
            }

            .matching-column {
                min-width: clamp(200px, 60vw, 320px);
            }

            .tf-btn {
                padding: 10px 18px;
                font-size: 0.9em;
            }
        }

        .progress-bar {
            width: 100%;
            height: 8px;
            background: #e8f4f8;
            border-radius: 10px;
            overflow: hidden;
            margin-top: 15px;
            box-shadow: inset 0 1px 3px rgba(0,0,0,0.1);
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #7ba3d4 0%, #5a8bc4 100%);
            transition: width 0.5s ease;
            box-shadow: 0 1px 2px rgba(123, 163, 212, 0.5);
            border-radius: 10px;
        }

        .start-btn {
            padding: 12px 30px;
            font-size: 1em;
            border: none;
            border-radius: 12px;
            background: #4CAF50;
            color: white;
            cursor: pointer;
            font-weight: 600;
            box-shadow: 0 5px 15px rgba(76, 175, 80, 0.3);
            transition: all 0.3s;
            font-family: 'Inter', 'Segoe UI', -apple-system, BlinkMacSystemFont, sans-serif;
        }

        .start-btn:hover {
            background: #45a049;
            transform: translateY(-2px);
            box-shadow: 0 7px 20px rgba(76, 175, 80, 0.4);
        }

        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.6);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10000;
            animation: fadeIn 0.3s;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .modal-content {
            background: white;
            padding: 40px;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            max-width: 500px;
            width: 90%;
            animation: slideUp 0.3s;
        }

        @keyframes slideUp {
            from {
                opacity: 0;
                transform: translateY(30px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .modal-title {
            font-size: 1.8em;
            color: #7ba3d4;
            margin-bottom: 30px;
            font-weight: 600;
            text-align: center;
        }

        .goal-options {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .goal-option {
            padding: 25px;
            border: 3px solid #e0e0e0;
            border-radius: 15px;
            cursor: pointer;
            transition: all 0.3s;
            text-align: center;
        }

        .goal-option:hover {
            border-color: #7ba3d4;
            background: #f8fbfd;
            transform: scale(1.02);
        }

        .goal-option-title {
            font-size: 1.2em;
            font-weight: 600;
            color: #2c3e50;
            margin-bottom: 10px;
        }

        .goal-option-desc {
            color: #6b7280;
            font-size: 1em;
        }

        .goal-input-container {
            margin-top: 20px;
        }

        .goal-input {
            width: 100%;
            padding: 15px;
            font-size: 1em;
            border: 3px solid #7ba3d4;
            border-radius: 12px;
            text-align: center;
            font-family: 'Inter', 'Segoe UI', -apple-system, BlinkMacSystemFont, sans-serif;
            font-weight: 600;
        }

        .goal-input:focus {
            outline: none;
            box-shadow: 0 0 0 3px rgba(123, 163, 212, 0.1);
        }

        .modal-buttons {
            display: flex;
            gap: 15px;
            margin-top: 25px;
        }

        .modal-btn {
            flex: 1;
            padding: 15px;
            font-size: 1em;
            border: none;
            border-radius: 12px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s;
            font-family: 'Inter', 'Segoe UI', -apple-system, BlinkMacSystemFont, sans-serif;
        }

        .modal-btn-primary {
            background: #7ba3d4;
            color: white;
        }

        .modal-btn-primary:hover {
            background: #6a92c3;
            transform: translateY(-2px);
        }

        .modal-btn-secondary {
            background: #e0e0e0;
            color: #2c3e50;
        }

        .modal-btn-secondary:hover {
            background: #d0d0d0;
        }

        .results-screen {
            text-align: center;
            padding: 40px;
        }

        .results-emoji {
            font-size: 6em;
            margin: 20px 0;
        }

        .results-title {
            font-size: 1.8em;
            color: #7ba3d4;
            font-weight: 600;
            margin-bottom: 30px;
        }

        .results-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 20px;
            margin: 30px 0;
        }

        .results-stat {
            padding: 20px;
            background: #f8fbfd;
            border-radius: 15px;
            border: 2px solid #e8f4f8;
        }

        .results-stat-value {
            font-size: 1.8em;
            font-weight: 600;
            color: #7ba3d4;
            margin-bottom: 5px;
        }

        .results-stat-label {
            color: #6b7280;
            font-size: 1em;
        }

        /* Results by exercise type section */
        .results-by-type-section {
            margin-top: 40px;
            padding-top: 30px;
            border-top: 2px solid #e8f4f8;
        }

        .results-by-type-title {
            font-size: 1.4em;
            color: #2c3e50;
            font-weight: 600;
            margin-bottom: 25px;
            text-align: center;
        }

        .results-type-cards {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin: 0 auto;
            max-width: 900px;
        }

        .results-type-card {
            padding: 20px;
            background: #ffffff;
            border-radius: 15px;
            border: 2px solid #e8f4f8;
            text-align: center;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .results-type-card:hover {
            border-color: #7ba3d4;
            box-shadow: 0 2px 8px rgba(123, 163, 212, 0.15);
        }

        .results-type-emoji {
            font-size: 2.5em;
            margin-bottom: 10px;
        }

        .results-type-name {
            font-size: 1em;
            font-weight: 600;
            color: #2c3e50;
            margin-bottom: 8px;
        }

        .results-type-total {
            font-size: 1.4em;
            font-weight: 700;
            color: #7ba3d4;
            margin: 10px 0;
        }

        .results-type-breakdown {
            margin: 10px 0;
            font-size: 0.95em;
        }

        .type-correct {
            color: #4CAF50;
            font-weight: 600;
        }

        .type-separator {
            color: #ccc;
            margin: 0 8px;
        }

        .type-incorrect {
            color: #f44336;
            font-weight: 600;
        }

        .results-type-percentage {
            font-size: 1.6em;
            font-weight: 700;
            color: #7ba3d4;
            margin: 12px 0;
        }

        .results-type-time {
            font-size: 0.85em;
            color: #6b7280;
            margin-top: 8px;
        }

        .results-type-empty {
            font-size: 0.9em;
            color: #9ca3af;
            font-style: italic;
            padding: 15px 0;
        }

        @media (max-width: 768px) {
            .results-type-cards {
                grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
                gap: 15px;
            }

            .results-type-card {
                padding: 15px;
            }

            .results-type-emoji {
                font-size: 2em;
            }
        }

        .overlay-blocker {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: #e8f4f8;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 9999;
        }

        .welcome-message {
            text-align: center;
            padding: 60px 40px;
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.15);
            max-width: 600px;
        }

        .welcome-message h2 {
            font-size: 1.8em;
            color: #7ba3d4;
            margin-bottom: 20px;
            font-weight: 600;
        }

        .welcome-message p {
            font-size: 1.2em;
            color: #6b7280;
            line-height: 1.6;
            margin-bottom: 30px;
        }

        .welcome-start-btn {
            padding: 20px 50px;
            font-size: 1.2em;
            border: none;
            border-radius: 15px;
            background: #4CAF50;
            color: white;
            cursor: pointer;
            font-weight: 600;
            box-shadow: 0 8px 20px rgba(76, 175, 80, 0.4);
            transition: all 0.3s;
            font-family: 'Inter', 'Segoe UI', -apple-system, BlinkMacSystemFont, sans-serif;
        }

        .welcome-start-btn:hover {
            background: #45a049;
            transform: translateY(-3px);
            box-shadow: 0 12px 30px rgba(76, 175, 80, 0.5);
        }

        /* Vocabulary Selector Screen */
        .vocabulary-selector-screen {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: #e8f4f8;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 15000;
            padding: 20px;
        }

        .vocabulary-selector-container {
            background: white;
            padding: 40px;
            border-radius: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            max-width: 500px;
            width: 100%;
            text-align: center;
        }

        .vocabulary-selector-title {
            color: #7ba3d4;
            font-size: 1.5em;
            margin-bottom: 30px;
            font-weight: 600;
        }

        .vocabulary-list {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .vocabulary-item {
            padding: 20px;
            border: 3px solid #e0e0e0;
            border-radius: 15px;
            background: white;
            cursor: pointer;
            transition: all 0.3s;
            text-align: left;
        }

        .vocabulary-item:hover {
            border-color: #7ba3d4;
            background: #f8fbfd;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(123, 163, 212, 0.2);
        }

        .vocabulary-item-label {
            font-weight: 600;
            color: #2c3e50;
            margin-bottom: 4px;
        }

        .vocabulary-item-count {
            font-size: 0.85em;
            color: #7f8c8d;
        }

        /* Change vocabulary button in header */
        .change-vocab-btn {
            background: none;
            border: none;
            font-size: 1.3em;
            cursor: pointer;
            padding: 4px 8px;
            border-radius: 8px;
            transition: background 0.2s;
        }

        .change-vocab-btn:hover {
            background: rgba(123, 163, 212, 0.1);
        }

        @media (max-width: 480px) {
            .vocabulary-selector-container {
                padding: 24px;
            }

            .vocabulary-item {
                padding: 16px;
            }
        }
    </style>
</head>
<body>
    <!-- Vocabulary Selector Screen -->
    <div id="vocabulary-selector-screen" class="vocabulary-selector-screen" style="display: none;">
        <div class="vocabulary-selector-container">
            <h2 class="vocabulary-selector-title" data-i18n="vocabularySelector.title">Kies je woordenschat</h2>
            <div id="vocabulary-list" class="vocabulary-list">
                <!-- Populated by JavaScript -->
            </div>
        </div>
    </div>

    <div class="container">
        <!-- Welcome blocker -->
        <div class="overlay-blocker" id="welcome-blocker">
            <div class="welcome-message">
                <h2 id="welcome-title"></h2>
                <p id="welcome-text">Klik op <strong>START</strong> om te beginnen met oefenen.</p>
                <button class="welcome-start-btn" id="welcome-start-btn">‚ñ∂Ô∏è START</button>
            </div>
        </div>

        <header id="app-header">
            <div class="header-top">
                <h1 style="margin: 0;" id="app-title"></h1>
                <button id="change-vocab-btn" class="change-vocab-btn" title="Change vocabulary" style="display: none;">üìö</button>
                <button id="start-btn" class="start-btn">‚ñ∂Ô∏è START</button>
            </div>

            <!-- Compact header row (visible only when scrolled) -->
            <div class="compact-row">
                <div class="compact-stats" id="compact-stats" aria-live="polite"></div>
            </div>

            <!-- Full header body (hidden in compact) -->
            <div class="header-body">
                <div id="timer-display" style="font-size: 1.8em; color: #7ba3d4; font-weight: 600; margin: 15px 0; display: none; text-align: center;">
                    ‚è±Ô∏è <span id="timer-text">00:00</span>
                </div>
                <p style="font-size: 1em; color: #6b7280; margin-top: 10px;" id="app-subtitle"></p>
                <div class="score-board">
                    <div class="score-item">
                        <span class="correct">‚úì <span id="correct-label">Goed</span>: <span id="correct-count">0</span></span>
                    </div>
                    <div class="score-item">
                        <span class="incorrect">‚úó <span id="incorrect-label">Fout</span>: <span id="incorrect-count">0</span></span>
                    </div>
                    <div class="score-item">
                        <span id="total-label">Totaal</span>: <span id="total-count">0</span>
                    </div>
                </div>
            </div>

            <!-- Progress bar (shows goal progress) -->
            <div class="progress-bar" id="header-progress-bar" style="display: none;">
                <div class="progress-fill" id="progress-fill" style="width: 0%"></div>
            </div>
        </header>

        <div class="theme-selector" id="theme-selector">
            <!-- Theme buttons will be generated dynamically from vocabulary.json -->
        </div>

        <div class="exercise-type-selector">
            <button class="exercise-type-btn active" data-type="multiple-choice" id="exercise-type-multiple">üéØ Meerkeuze</button>
            <button class="exercise-type-btn" data-type="fill-in" id="exercise-type-fill">‚úèÔ∏è Invullen</button>
            <button class="exercise-type-btn" data-type="matching" id="exercise-type-matching">üîó Koppelen</button>
            <button class="exercise-type-btn" data-type="true-false" id="exercise-type-truefalse">‚úì/‚úó Waar/Niet waar</button>
        </div>

        <div class="card" id="exercise-card">
            <!-- Exercises will appear here after START -->
        </div>
        
        <!-- Floating language switcher -->
        <div id="lang-switcher" class="lang-switcher" aria-label="Language switcher"></div>
    </div>

    <script>
        // ============================================
        // DATA LOADING (STATIC JSON FILES)
        // ============================================

        /**
         * VOCABULARY DATA STRUCTURE
         *
         * Expected format for vocabulary items:
         * {
         *   "word": "string",                    // Required: The word or phrase to learn
         *   "definition": "string",              // Required: The primary definition
         *   "alternativeDefinitions": ["string"] // Optional: Array of alternative definitions that mean the same
         * }
         *
         * The "alternativeDefinitions" field is optional and currently not used in exercises.
         * If present, it should be an array of strings representing alternative ways to express
         * the same definition. Words without this field will continue to work normally.
         *
         * Example:
         * {
         *   "word": "ontwaken",
         *   "definition": "wakker worden",
         *   "alternativeDefinitions": ["wakker worden uit de slaap", "je ogen openen"]
         * }
         */

        const DATA_SOURCES = {
            vocabulary: 'vocabulary.json',
            config: 'config.json'
        };
        const TRANSLATIONS_DIR = 'translations';

        const DEFAULT_LANGUAGE = 'nl';

        let vocabularyData = null;
        let translationsData = null;
        let translation = null;
        let currentLanguage = DEFAULT_LANGUAGE;
        let themeOptions = {};
        let appMetadata = {};
        let appConfig = {};
        let dataReady = false;
        let useThemeDropdown = false;
        let themeSelectElement = null;
        let selectedVocabularyId = null;
        const VOCAB_STORAGE_KEY = 'selectedVocabulary';

        function t(path, replacements = {}) {
            if (!translation) return path;
            const value = path.split('.').reduce((acc, key) => acc && acc[key], translation);
            if (!value) return path;
            return Object.entries(replacements).reduce((acc, [key, val]) => {
                const pattern = new RegExp(`{{\\s*${key}\\s*}}`, 'g');
                return acc.replace(pattern, val);
            }, value);
        }

        function loadJSONViaFrame(path) {
            return new Promise((resolve, reject) => {
                const iframe = document.createElement('iframe');
                iframe.style.display = 'none';
                iframe.src = path;

                const cleanup = () => {
                    if (iframe.parentNode) {
                        iframe.parentNode.removeChild(iframe);
                    }
                };

                iframe.onload = () => {
                    try {
                        const doc = iframe.contentDocument || iframe.contentWindow.document;
                        const text = doc.body ? doc.body.innerText : doc.documentElement.textContent;
                        resolve(JSON.parse(text));
                    } catch (error) {
                        reject(error);
                    } finally {
                        cleanup();
                    }
                };

                iframe.onerror = () => {
                    cleanup();
                    reject(new Error(`Kon ${path} niet laden via fallback`));
                };

                document.body.appendChild(iframe);
            });
        }

        async function loadJSONResource(path) {
            try {
                const response = await fetch(path, { cache: 'no-store' });
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}`);
                }
                return await response.json();
            } catch (error) {
                console.warn(`Fetch voor ${path} is mislukt, probeer fallback...`, error);
                if (window.location.protocol === 'file:') {
                    return await loadJSONViaFrame(path);
                }
                throw error;
            }
        }

        async function listTranslationCodesFromServer() {
            try {
                const res = await fetch(`${TRANSLATIONS_DIR}/`, { cache: 'no-store' });
                if (!res.ok) return [];
                const html = await res.text();
                const re = /messages\.([a-zA-Z-]+)\.json/g;
                const found = new Set();
                let m;
                while ((m = re.exec(html))) {
                    found.add(m[1].toLowerCase());
                }
                return Array.from(found);
            } catch (err) {
                console.warn('Could not list translations directory; falling back to defaults.', err);
                return [];
            }
        }

        async function loadTranslationsFromFolder() {
            // Try to discover languages by listing the directory (works on most static servers)
            let codes = await listTranslationCodesFromServer();
            // Fallback to a sensible default set if listing is unavailable
            if (!codes.length) codes = ['nl', 'es', 'en', 'pl', 'tr'];

            const result = {};
            await Promise.all(codes.map(async (code) => {
                try {
                    const data = await loadJSONResource(`${TRANSLATIONS_DIR}/messages.${code}.json`);
                    if (data) result[code] = data;
                } catch (e) {
                    console.warn(`Failed to load ${code} messages`, e);
                }
            }));
            return result;
        }

        async function loadData() {
            try {
                let cfgJson = null;
                try {
                    cfgJson = await loadJSONResource(DATA_SOURCES.config);
                } catch (configError) {
                    console.warn('Kon config.json niet volledig laden; gebruik standaarden.', configError);
                }

                appConfig = cfgJson || {};

                // Check for saved vocabulary selection
                const savedVocabId = localStorage.getItem(VOCAB_STORAGE_KEY);
                const vocabList = appConfig.vocabularies || [];

                // Legacy support: if no vocabularies array but vocabularyFile exists
                if (vocabList.length === 0 && appConfig.vocabularyFile) {
                    vocabList.push({
                        id: 'default',
                        file: appConfig.vocabularyFile,
                        label: 'Default'
                    });
                }

                // Load translations first (needed for selector screen)
                const allTranslations = await loadTranslationsFromFolder();
                translationsData = allTranslations;
                const savedLang = localStorage.getItem('vt_lang');
                const preferredLang = savedLang || appConfig?.defaultLanguage || DEFAULT_LANGUAGE;
                currentLanguage = translationsData[preferredLang] ? preferredLang : DEFAULT_LANGUAGE;
                translation = translationsData[currentLanguage] || Object.values(translationsData)[0];

                // Check if we need to show selector
                const savedVocab = vocabList.find(v => v.id === savedVocabId);

                if (!savedVocab && vocabList.length > 1) {
                    // Show vocabulary selector
                    initLanguageSwitcher();
                    showVocabularySelector();
                    dataReady = true;
                    return;
                }

                // Load the vocabulary (saved or first available)
                const vocabToLoad = savedVocab || vocabList[0];
                if (!vocabToLoad) {
                    throw new Error('No vocabulary configured');
                }

                selectedVocabularyId = vocabToLoad.id;
                let vocabJson = null;

                try {
                    vocabJson = await loadJSONResource(vocabToLoad.file);
                } catch (err) {
                    console.error(`Error loading vocabulary '${vocabToLoad.file}':`, err);
                    // If saved vocab failed, clear and show selector
                    if (savedVocab && vocabList.length > 1) {
                        localStorage.removeItem(VOCAB_STORAGE_KEY);
                        showVocabularySelector();
                        dataReady = true;
                        return;
                    }
                    throw err;
                }

                vocabularyData = vocabJson;
                appMetadata = vocabularyData?.metadata || {};
                themeOptions = buildThemeOptions(vocabularyData);
                useThemeDropdown = Object.keys(vocabularyData?.themes || {}).length > 4;

                // Show change button if multiple vocabularies
                const changeBtn = document.getElementById('change-vocab-btn');
                if (changeBtn && vocabList.length > 1) {
                    changeBtn.style.display = 'block';
                    changeBtn.title = t('vocabularySelector.changeVocabulary') || 'Andere woordenschat';
                }

                applyTranslations();
                initializeApp();
                initLanguageSwitcher();
                dataReady = true;
            } catch (error) {
                console.error('Fout bij het laden van data:', error);
                showDataError(error);
            }
        }

        function buildThemeOptions(data) {
            const themes = data?.themes || {};
            const options = {
                all: `üåü ${t('themes.allWeeks') || 'Alle weken'}`
            };

            Object.entries(themes).forEach(([themeId, themeData]) => {
                const emoji = themeData.emoji ? `${themeData.emoji} ` : '';
                options[themeId] = `${emoji}${themeData.name}`;
            });

            return options;
        }

        function countVocabularyWords(vocabData) {
            if (!vocabData?.themes) return 0;
            return Object.values(vocabData.themes).reduce((total, theme) => {
                return total + (theme.vocabulary?.length || 0);
            }, 0);
        }

        async function showVocabularySelector() {
            const screen = document.getElementById('vocabulary-selector-screen');
            const list = document.getElementById('vocabulary-list');
            const changeBtn = document.getElementById('change-vocab-btn');

            if (!screen || !list) return;

            // Hide main app, show selector
            document.querySelector('.container').style.display = 'none';
            screen.style.display = 'flex';
            if (changeBtn) changeBtn.style.display = 'none';

            // Clear existing items
            list.innerHTML = '';

            // Load word counts for each vocabulary
            for (const vocab of appConfig.vocabularies || []) {
                const item = document.createElement('div');
                item.className = 'vocabulary-item';
                item.dataset.vocabId = vocab.id;

                // Try to load vocabulary to get word count
                let wordCount = '...';
                try {
                    const vocabData = await loadJSONResource(vocab.file);
                    wordCount = countVocabularyWords(vocabData);
                } catch (e) {
                    wordCount = '?';
                }

                item.innerHTML = `
                    <div class="vocabulary-item-label">${vocab.label}</div>
                    <div class="vocabulary-item-count">${wordCount} ${t('vocabularySelector.words') || 'woorden'}</div>
                `;

                item.addEventListener('click', () => selectVocabulary(vocab.id));
                list.appendChild(item);
            }

            // Update title translation
            const title = screen.querySelector('.vocabulary-selector-title');
            if (title) title.textContent = t('vocabularySelector.title') || 'Kies je woordenschat';
        }

        async function selectVocabulary(vocabId) {
            const vocab = appConfig.vocabularies?.find(v => v.id === vocabId);
            if (!vocab) return;

            // Save selection
            localStorage.setItem(VOCAB_STORAGE_KEY, vocabId);
            selectedVocabularyId = vocabId;

            // Load the vocabulary
            try {
                vocabularyData = await loadJSONResource(vocab.file);
                appMetadata = vocabularyData?.metadata || {};
                themeOptions = buildThemeOptions(vocabularyData);
                useThemeDropdown = Object.keys(vocabularyData?.themes || {}).length > 4;

                // Hide selector, show app
                document.getElementById('vocabulary-selector-screen').style.display = 'none';
                document.querySelector('.container').style.display = 'block';

                const changeBtn = document.getElementById('change-vocab-btn');
                if (changeBtn) {
                    changeBtn.style.display = 'block';
                    changeBtn.title = t('vocabularySelector.changeVocabulary') || 'Andere woordenschat';
                }

                // Reinitialize app with new vocabulary
                applyTranslations();
                initializeApp();

                // Reset session state
                resetStats();
                sessionActive = false;
                updateUI();

            } catch (error) {
                console.error('Error loading vocabulary:', error);
                localStorage.removeItem(VOCAB_STORAGE_KEY);
                showVocabularySelector();
            }
        }

        function clearVocabularySelection() {
            localStorage.removeItem(VOCAB_STORAGE_KEY);
            selectedVocabularyId = null;
            showVocabularySelector();
        }

        function getVocabularySubtitle() {
            if (!vocabularyData?.themes || Object.keys(vocabularyData.themes).length === 0) {
                return appMetadata?.title || '';
            }

            if (currentTheme !== 'all' && vocabularyData.themes[currentTheme]) {
                const theme = vocabularyData.themes[currentTheme];
                const emoji = theme?.emoji ? `${theme.emoji} ` : '';
                return `${emoji}${theme?.name || ''}`.trim();
            }

            if (appMetadata?.title) {
                return appMetadata.title;
            }

            const firstTheme = Object.values(vocabularyData.themes)[0];
            if (!firstTheme) return '';
            const emoji = firstTheme.emoji ? `${firstTheme.emoji} ` : '';
            return `${emoji}${firstTheme.name || ''}`.trim();
        }

        function updateSubtitle() {
            const subtitleText = getVocabularySubtitle();
            const baseTitle = translation?.app?.title || (document.title ? document.title.split(' - ')[0] : 'Vocabulary Trainer');
            const fullTitle = subtitleText ? `${baseTitle} - ${subtitleText}` : baseTitle;
            document.title = fullTitle;

            const appSubtitle = document.getElementById('app-subtitle');
            if (appSubtitle) {
                appSubtitle.textContent = subtitleText;
            }
        }

        function applyTranslations() {
            if (!translation) return;

            const appTitle = document.getElementById('app-title');
            if (appTitle) {
                appTitle.textContent = translation.app.title;
            }

            const welcomeTitle = document.getElementById('welcome-title');
            if (welcomeTitle) {
                welcomeTitle.textContent = translation.app.welcomeTitle;
            }

            const welcomeText = document.getElementById('welcome-text');
            if (welcomeText) {
                welcomeText.innerHTML = translation.app.welcomeText;
            }

            updateSubtitle();

            const startBtn = document.getElementById('start-btn');
            if (startBtn) {
                startBtn.innerHTML = `‚ñ∂Ô∏è ${translation.app.startButton}`;
            }

            const welcomeStartBtn = document.getElementById('welcome-start-btn');
            if (welcomeStartBtn) {
                welcomeStartBtn.innerHTML = `‚ñ∂Ô∏è ${translation.app.startButton}`;
            }

            const correctLabel = document.getElementById('correct-label');
            if (correctLabel) {
                correctLabel.textContent = translation.stats.correct;
            }

            const incorrectLabel = document.getElementById('incorrect-label');
            if (incorrectLabel) {
                incorrectLabel.textContent = translation.stats.incorrect;
            }

            const totalLabel = document.getElementById('total-label');
            if (totalLabel) {
                totalLabel.textContent = translation.stats.total;
            }

            const exerciseTypeMultiple = document.getElementById('exercise-type-multiple');
            if (exerciseTypeMultiple) {
                exerciseTypeMultiple.textContent = `üéØ ${translation.exerciseTypes.multipleChoice}`;
            }

            const exerciseTypeFill = document.getElementById('exercise-type-fill');
            if (exerciseTypeFill) {
                exerciseTypeFill.textContent = `‚úèÔ∏è ${translation.exerciseTypes.fillIn}`;
            }

            const exerciseTypeMatching = document.getElementById('exercise-type-matching');
            if (exerciseTypeMatching) {
                exerciseTypeMatching.textContent = `üîó ${translation.exerciseTypes.matching}`;
            }

            const exerciseTypeTrueFalse = document.getElementById('exercise-type-truefalse');
            if (exerciseTypeTrueFalse) {
                exerciseTypeTrueFalse.textContent = `‚úì/‚úó ${translation.exerciseTypes.trueFalse}`;
            }

            updatePendingCounter();
            // Ensure compact stats initialize with correct label
            updateScore();
        }

        function computeFlagEmoji(country) {
            if (!country || country.length < 2) return '';
            const cc = country.slice(-2).toUpperCase();
            const A = 0x1F1E6; // Regional Indicator Symbol Letter A
            const base = 'A'.charCodeAt(0);
            const chars = Array.from(cc).map(c => String.fromCodePoint(A + (c.charCodeAt(0) - base)));
            return chars.join('');
        }

        function codeToCountry(code) {
            const c = (code || '').toLowerCase();
            const map = {
                'nl': 'nl', 'es': 'es', 'en': 'gb', 'en-gb': 'gb', 'en-us': 'us',
                'fr': 'fr', 'de': 'de', 'it': 'it', 'pt': 'pt', 'pt-br': 'br',
                'pl': 'pl', 'tr': 'tr', 'ru': 'ru', 'uk': 'ua', 'ja': 'jp',
                'zh': 'cn', 'zh-cn': 'cn', 'zh-tw': 'tw', 'ar': 'sa'
            };
            return map[c] || (c.includes('-') ? c.split('-').pop() : c);
        }

        function flagFor(code) {
            const country = codeToCountry(code);
            const emoji = computeFlagEmoji(country);
            return emoji || country.toUpperCase();
        }

        function flagAssetPath(code) {
            const country = codeToCountry(code);
            return `flags/${country}.svg`;
        }

        function setLanguage(lang) {
            if (!translationsData || !translationsData[lang]) return;
            currentLanguage = lang;
            localStorage.setItem('vt_lang', currentLanguage);
            translation = translationsData[currentLanguage];
            applyTranslations();
            updatePendingCounter();
            updateScore();

            // Re-render results screen if currently showing
            if (resultsShown) {
                showResultsScreen();
            } else if (typeof generateExercise === 'function' && dataReady && sessionActive) {
                // Re-render current exercise UI with new copy
                generateExercise();
            }

            // Update active styling
            document.querySelectorAll('.lang-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.lang === currentLanguage);
            });
        }

        function initLanguageSwitcher() {
            let container = document.getElementById('lang-switcher');
            if (!container) {
                container = document.createElement('div');
                container.id = 'lang-switcher';
                container.className = 'lang-switcher';
                document.body.appendChild(container);
            }
            if (!container || !translationsData) return;
            container.innerHTML = '';
            const codes = Object.keys(translationsData);
            codes.forEach(code => {
                const btn = document.createElement('button');
                btn.type = 'button';
                btn.className = 'lang-btn' + (code === currentLanguage ? ' active' : '');
                btn.dataset.lang = code;
                const title = code.toUpperCase();
                btn.title = title;
                btn.setAttribute('aria-label', `Change language to ${title}`);
                // Prefer SVG asset; fallback to emoji; final fallback code
                const img = new Image();
                img.alt = title;
                img.src = flagAssetPath(code);
                img.addEventListener('error', () => {
                    // fallback to emoji/text when asset not found
                    btn.textContent = flagFor(code);
                });
                btn.appendChild(img);
                btn.addEventListener('click', () => setLanguage(code));
                container.appendChild(btn);
            });
        }

        function showDataError(error) {
            const blocker = document.getElementById('welcome-blocker');
            if (blocker) blocker.style.display = 'none';

            const card = document.getElementById('exercise-card');
            if (card) {
                card.innerHTML = `
                    <div class="results-screen" style="color: #f44336;">
                        <div class="results-emoji">‚ö†Ô∏è</div>
                        <p>Er ging iets mis bij het laden van de data. Zorg dat je deze pagina opent via een lokaal webserver (bijv. <code>npx serve</code>) of probeer het opnieuw.</p>
                        <pre style="margin-top: 10px; color: #d32f2f;">${error.message}</pre>
                    </div>
                `;
            }
        }

        // ============================================
        // END OF CONFIGURATION
        // ============================================

        let currentTheme = 1;
        let currentExerciseType = 'multiple-choice';
        let correctCount = 0;
        let incorrectCount = 0;
        let totalCount = 0;
        let currentQuestion = null;
        let matchingSelections = [];
        let matchingPool = [];
        let activeMatches = [];
        let matchingLocked = false;
        const MATCHING_ACTIVE_SIZE = 5;

        function clearMatchingState() {
            matchingPool = [];
            activeMatches = [];
            matchingSelections = [];
            matchingLocked = false;
        }

        // Session state
        let sessionActive = false;
        let resultsShown = false;
        let sessionGoalType = null; // 'time' or 'exercises'
        let sessionGoalValue = 0;
        let sessionStartTime = null;
        let timerInterval = null;
        let sessionTimeElapsed = 0; // in seconds
        let sessionTimeRemaining = 0; // in seconds (for countdown)

        // Exercise statistics by type (for results screen)
        let exerciseStats = {
            'multiple-choice': { total: 0, correct: 0, incorrect: 0, totalTimeMs: 0, questionStartTime: null },
            'fill-in': { total: 0, correct: 0, incorrect: 0, totalTimeMs: 0, questionStartTime: null },
            'matching': { total: 0, correct: 0, incorrect: 0, totalTimeMs: 0, questionStartTime: null },
            'true-false': { total: 0, correct: 0, incorrect: 0, totalTimeMs: 0, questionStartTime: null }
        };

        // Get vocabulary based on current theme
        function getCurrentVocabulary() {
            if (!vocabularyData?.themes) {
                return [];
            }

            if (currentTheme === 'all') {
                return Object.values(vocabularyData.themes).flatMap(theme => theme.vocabulary);
            }

            const theme = vocabularyData.themes[currentTheme];
            return theme ? theme.vocabulary : [];
        }

        // Timer functions
        function formatTime(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = seconds % 60;
            return `${String(mins).padStart(2, '0')}:${String(secs).padStart(2, '0')}`;
        }

        function updateProgressBar() {
            const progressBar = document.getElementById('header-progress-bar');
            const progressFill = document.getElementById('progress-fill');

            if (!sessionActive || !progressBar || !progressFill) return;

            if (sessionGoalType === 'exercises') {
                // Show exercises progress (visual only, no text)
                const progress = Math.min(totalCount, sessionGoalValue);
                const percentage = (progress / sessionGoalValue) * 100;
                progressFill.style.width = percentage + '%';
            } else if (sessionGoalType === 'time') {
                // Show time progress (visual only, no text)
                const totalSeconds = sessionGoalValue * 60;
                const percentage = Math.min((sessionTimeElapsed / totalSeconds) * 100, 100);
                progressFill.style.width = percentage + '%';
            }
        }

        function updateCompactTimer() {
            // Update compact stats line with current timer
            const compact = document.getElementById('compact-stats');
            if (compact && sessionActive) {
                const pendingLabel = getStatLabel('pending', 'Nog te doen');
                const totalLabel = getStatLabel('total', 'Totaal');
                const remaining = (sessionActive && sessionGoalType === 'exercises')
                    ? Math.max(sessionGoalValue - totalCount, 0)
                    : totalCount;
                const labelToUse = (sessionActive && sessionGoalType === 'exercises') ? pendingLabel : totalLabel;

                // Get timer text
                const timerText = document.getElementById('timer-text');
                const timerDisplay = timerText ? timerText.textContent : '00:00';

                compact.innerHTML = `
                    <span style="font-size: 1.3em; color: #7ba3d4; font-weight: 600;">‚è±Ô∏è ${timerDisplay}</span>
                    |
                    <span class="stat-correct">‚úì ${correctCount}</span>
                    |
                    <span class="stat-incorrect">‚úó ${incorrectCount}</span>
                    |
                    <span class="stat-pending">${labelToUse}: ${remaining}</span>
                `;
            }
        }

        function startTimer() {
            if (timerInterval) clearInterval(timerInterval);

            if (sessionGoalType === 'time') {
                // Countdown mode
                sessionTimeRemaining = sessionGoalValue * 60;
                timerInterval = setInterval(() => {
                    sessionTimeRemaining--;
                    sessionTimeElapsed++;
                    document.getElementById('timer-text').textContent = formatTime(sessionTimeRemaining);

                    // Update progress bar every second
                    updateProgressBar();

                    // Update compact timer
                    updateCompactTimer();

                    if (sessionTimeRemaining <= 0) {
                        endSession();
                    }
                }, 1000);
            } else {
                // Count up mode
                sessionTimeElapsed = 0;
                timerInterval = setInterval(() => {
                    sessionTimeElapsed++;
                    document.getElementById('timer-text').textContent = formatTime(sessionTimeElapsed);

                    // Update compact timer
                    updateCompactTimer();
                }, 1000);
            }
        }

        function stopTimer() {
            if (timerInterval) {
                clearInterval(timerInterval);
                timerInterval = null;
            }
        }

        function updateStartButton() {
            const startBtn = document.getElementById('start-btn');
            if (startBtn) {
                if (sessionActive) {
                    startBtn.innerHTML = `üîÑ ${t('app.restartButton')}`;
                } else {
                    startBtn.innerHTML = `‚ñ∂Ô∏è ${t('app.startButton')}`;
                }
            }
        }

        function resetSession() {
            sessionActive = false;
            resultsShown = false;
            sessionGoalType = null;
            sessionGoalValue = 0;
            sessionStartTime = null;
            sessionTimeElapsed = 0;
            sessionTimeRemaining = 0;
            correctCount = 0;
            incorrectCount = 0;
            totalCount = 0;
            clearMatchingState();
            stopTimer();
            updateScore();
            updateStartButton();
            document.getElementById('timer-display').style.display = 'none';
            document.getElementById('timer-text').textContent = '00:00';

            // Reset exercise statistics
            exerciseStats = {
                'multiple-choice': { total: 0, correct: 0, incorrect: 0, totalTimeMs: 0, questionStartTime: null },
                'fill-in': { total: 0, correct: 0, incorrect: 0, totalTimeMs: 0, questionStartTime: null },
                'matching': { total: 0, correct: 0, incorrect: 0, totalTimeMs: 0, questionStartTime: null },
                'true-false': { total: 0, correct: 0, incorrect: 0, totalTimeMs: 0, questionStartTime: null }
            };

            // Hide progress bar
            const progressBar = document.getElementById('header-progress-bar');
            if (progressBar) {
                progressBar.style.display = 'none';
            }

            // Show theme and exercise selectors again
            const themeSelector = document.querySelector('.theme-selector');
            const exerciseTypeSelector = document.querySelector('.exercise-type-selector');
            if (themeSelector) themeSelector.style.display = 'flex';
            if (exerciseTypeSelector) exerciseTypeSelector.style.display = 'flex';
        }

        function checkSessionGoal() {
            if (!sessionActive) return;
            
            if (sessionGoalType === 'exercises' && totalCount >= sessionGoalValue) {
                endSession();
            }
        }

        function endSession() {
            stopTimer();
            sessionActive = false;
            resultsShown = true;

            // Use setTimeout to ensure all feedback rendering is complete before clearing
            setTimeout(() => {
                // Clear exercise card content before showing results
                const exerciseCard = document.getElementById('exercise-card');
                if (exerciseCard) {
                    exerciseCard.innerHTML = '';
                }

                showResultsScreen();
            }, 100);
        }

        function getEmojiForScore(percentage) {
            if (percentage >= 95) return 'üåü'; // Level 10
            if (percentage >= 85) return 'üéâ'; // Level 9
            if (percentage >= 75) return 'üòä'; // Level 8
            if (percentage >= 65) return 'üëç'; // Level 7
            if (percentage >= 55) return 'üôÇ'; // Level 6
            if (percentage >= 45) return 'üòê'; // Level 5
            if (percentage >= 35) return 'üòï'; // Level 4
            if (percentage >= 25) return 'üòû'; // Level 3
            if (percentage >= 15) return 'üò¢'; // Level 2
            return 'üí™'; // Level 1
        }

        function getMessageForScore(percentage) {
            if (!translation?.results) {
                if (percentage >= 95) return 'Perfect! Je bent een ster!';
                if (percentage >= 85) return 'Uitstekend gedaan!';
                if (percentage >= 75) return 'Heel goed werk!';
                if (percentage >= 65) return 'Goed gedaan!';
                if (percentage >= 55) return 'Redelijk goed!';
                if (percentage >= 45) return 'Je kunt het beter!';
                if (percentage >= 35) return 'Meer oefenen nodig!';
                if (percentage >= 25) return 'Blijf oefenen!';
                if (percentage >= 15) return 'Niet opgeven!';
                return 'Blijf proberen, je kunt het!';
            }

            if (percentage >= 95) return translation.results.level10;
            if (percentage >= 85) return translation.results.level9;
            if (percentage >= 75) return translation.results.level8;
            if (percentage >= 65) return translation.results.level7;
            if (percentage >= 55) return translation.results.level6;
            if (percentage >= 45) return translation.results.level5;
            if (percentage >= 35) return translation.results.level4;
            if (percentage >= 25) return translation.results.level3;
            if (percentage >= 15) return translation.results.level2;
            return translation.results.level1;
        }

        function showResultsScreen() {
            const percentage = totalCount > 0 ? Math.round((correctCount / totalCount) * 100) : 0;
            const emoji = getEmojiForScore(percentage);
            const message = getMessageForScore(percentage);
            const timeDisplay = formatTime(sessionTimeElapsed);

            // Generate exercise type statistics
            const exerciseTypes = [
                { key: 'multiple-choice', emoji: 'üéØ', name: t('exerciseTypes.multipleChoice') },
                { key: 'fill-in', emoji: '‚úèÔ∏è', name: t('exerciseTypes.fillIn') },
                { key: 'matching', emoji: 'üîó', name: t('exerciseTypes.matching') },
                { key: 'true-false', emoji: '‚úì/‚úó', name: t('exerciseTypes.trueFalse') }
            ];

            let typeStatsHTML = '';
            exerciseTypes.forEach(type => {
                const stats = exerciseStats[type.key];
                const typePercentage = stats.total > 0 ? Math.round((stats.correct / stats.total) * 100) : 0;
                const avgTimeSeconds = stats.total > 0 ? Math.round(stats.totalTimeMs / stats.total / 1000) : 0;

                typeStatsHTML += `
                    <div class="results-type-card">
                        <div class="results-type-emoji">${type.emoji}</div>
                        <div class="results-type-name">${type.name}</div>
                        <div class="results-type-total">${stats.total} ${stats.total === 1 ? t('results.question') : t('results.questions')}</div>
                        ${stats.total > 0 ? `
                            <div class="results-type-breakdown">
                                <span class="type-correct">‚úì ${stats.correct}</span>
                                <span class="type-separator">|</span>
                                <span class="type-incorrect">‚úó ${stats.incorrect}</span>
                            </div>
                            <div class="results-type-percentage">${typePercentage}%</div>
                            <div class="results-type-time">‚è±Ô∏è ${avgTimeSeconds}s / ${t('results.avgTimePerQuestion')}</div>
                        ` : `
                            <div class="results-type-empty">${t('results.noQuestionsOfType')}</div>
                        `}
                    </div>
                `;
            });

            const html = `
                <div class="results-screen">
                    <div class="results-emoji">${emoji}</div>
                    <div class="results-title">${t('results.finished')}</div>
                    <p style="font-size: 1.2em; color: #2c3e50; margin-bottom: 20px;">${message}</p>

                    <div class="results-stats">
                        <div class="results-stat">
                            <div class="results-stat-value">${timeDisplay}</div>
                            <div class="results-stat-label">${t('results.time')}</div>
                        </div>
                        <div class="results-stat">
                            <div class="results-stat-value">${totalCount}</div>
                            <div class="results-stat-label">${t('results.totalQuestions')}</div>
                        </div>
                        <div class="results-stat">
                            <div class="results-stat-value" style="color: #4CAF50;">${correctCount}</div>
                            <div class="results-stat-label">${t('stats.correct')}</div>
                        </div>
                        <div class="results-stat">
                            <div class="results-stat-value" style="color: #f44336;">${incorrectCount}</div>
                            <div class="results-stat-label">${t('stats.incorrect')}</div>
                        </div>
                        <div class="results-stat">
                            <div class="results-stat-value">${percentage}%</div>
                            <div class="results-stat-label">${t('results.score')}</div>
                        </div>
                    </div>

                    <div class="results-by-type-section">
                        <h3 class="results-by-type-title">${t('results.byExerciseType')}</h3>
                        <div class="results-type-cards">
                            ${typeStatsHTML}
                        </div>
                    </div>

                    <!-- Restart handled via header START/RESTART button -->
                </div>
            `;

            // Set the results HTML
            document.getElementById('exercise-card').innerHTML = html;

            // Hide theme and exercise selectors
            document.querySelector('.theme-selector').style.display = 'none';
            document.querySelector('.exercise-type-selector').style.display = 'none';

            // Hide progress bar
            const progressBar = document.getElementById('header-progress-bar');
            if (progressBar) {
                progressBar.style.display = 'none';
            }
        }

        function showGoalModal() {
            if (!dataReady) return;
            console.log('showGoalModal called');
            const modal = document.createElement('div');
            modal.className = 'modal-overlay';
            modal.id = 'goal-modal';
            
            modal.innerHTML = `
                <div class="modal-content">
                    <div class="modal-title">üéØ ${t('goals.title')}</div>
                    
                    <div class="goal-options">
                        <div class="goal-option" data-goal-type="time">
                            <div class="goal-option-title">‚è±Ô∏è ${t('goals.time')}</div>
                            <div class="goal-option-desc">${t('goals.timeDesc')}</div>
                        </div>
                        
                        <div class="goal-option" data-goal-type="exercises">
                            <div class="goal-option-title">üéØ ${t('goals.exercises')}</div>
                            <div class="goal-option-desc">${t('goals.exercisesDesc')}</div>
                        </div>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
            console.log('Modal appended to body');
            
            // Add click listeners to goal options
            document.querySelectorAll('.goal-option').forEach(option => {
                option.addEventListener('click', function() {
                    console.log('Goal option clicked:', this.dataset.goalType);
                    selectGoalType(this.dataset.goalType);
                });
            });
        }

        function selectGoalType(type) {
            const modal = document.getElementById('goal-modal');
            const modalContent = modal.querySelector('.modal-content');
            
            const goalsCfg = appConfig?.goals || {};
            const goalCfg = type === 'time' ? (goalsCfg.time || {}) : (goalsCfg.exercises || {});
            const minValue = Number.isFinite(goalCfg.min) ? goalCfg.min : (type === 'time' ? 1 : 10);
            const maxValue = Number.isFinite(goalCfg.max) ? goalCfg.max : (type === 'time' ? 60 : 100);
            const defValue = Number.isFinite(goalCfg.default) ? goalCfg.default : (type === 'time' ? 5 : 20);
            const label = type === 'time' ? t('goals.time').toLowerCase() : t('goals.exercises').toLowerCase();
            const emoji = type === 'time' ? '‚è±Ô∏è' : 'üéØ';
            const question = type === 'time' ? t('goals.howManyMinutes') : t('goals.howManyExercises');
            const placeholder = t('goals.enterValue', { type: label });
            
            modalContent.innerHTML = `
                <div class="modal-title">${emoji} ${question}</div>
                
                <div class="goal-input-container">
                    <input 
                        type="number" 
                        class="goal-input" 
                        id="goal-value-input"
                        min="${minValue}" 
                        max="${maxValue}" 
                        value="${defValue}"
                        placeholder="${placeholder}"
                    >
                </div>
                
                <div class="modal-buttons">
                    <button class="modal-btn modal-btn-secondary" id="cancel-goal-btn">
                        ${t('goals.cancel')}
                    </button>
                    <button class="modal-btn modal-btn-primary" id="start-goal-btn">
                        ${t('goals.start')}
                    </button>
                </div>
            `;
            
            document.getElementById('goal-value-input').focus();
            
            // Add event listeners
            document.getElementById('cancel-goal-btn').addEventListener('click', closeGoalModal);
            document.getElementById('start-goal-btn').addEventListener('click', () => startSession(type));
            document.getElementById('goal-value-input').addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    startSession(type);
                }
            });
        }

        function closeGoalModal() {
            const modal = document.getElementById('goal-modal');
            if (modal) modal.remove();
            
            // Resume timer if session was active before opening modal
            if (sessionActive && timerInterval === null) {
                startTimer();
            }
        }

        function startSession(type) {
            const input = document.getElementById('goal-value-input');
            const value = parseInt(input.value);
            
            const goalsCfg = appConfig?.goals || {};
            const goalCfg = type === 'time' ? (goalsCfg.time || {}) : (goalsCfg.exercises || {});
            const minValue = Number.isFinite(goalCfg.min) ? goalCfg.min : (type === 'time' ? 1 : 10);
            const maxValue = Number.isFinite(goalCfg.max) ? goalCfg.max : (type === 'time' ? 60 : 100);
            
            if (!value || value < minValue || value > maxValue) {
                alert(t('goals.validationError', { min: minValue, max: maxValue }));
                return;
            }
            
            closeGoalModal();
            
            // Remove welcome blocker
            const blocker = document.getElementById('welcome-blocker');
            if (blocker) blocker.remove();
            
            // Reset everything (this will stop any existing timer)
            resetSession();
            
            // Set session parameters
            sessionActive = true;
            sessionGoalType = type;
            sessionGoalValue = value;
            sessionStartTime = Date.now();
            
            // Update START button text and sync counters (incl. compact line)
            updateStartButton();
            updatePendingCounter();
            updateScore();

            // Show and start timer
            document.getElementById('timer-display').style.display = 'block';
            if (type === 'time') {
                document.getElementById('timer-text').textContent = formatTime(value * 60);
            } else {
                document.getElementById('timer-text').textContent = '00:00';
            }
            startTimer();

            // Show progress bar
            const progressBar = document.getElementById('header-progress-bar');
            if (progressBar) {
                progressBar.style.display = 'block';
            }

            // Initialize progress bar
            updateProgressBar();

            // Generate first exercise
            generateExercise();
        }

        // START button handler
        const startBtn = document.getElementById('start-btn');
        if (startBtn) {
            startBtn.addEventListener('click', () => {
                console.log('Header START button clicked');
                if (sessionActive) {
                    // Pause timer while showing modal
                    stopTimer();
                    showGoalModal();
                } else {
                    showGoalModal();
                }
            });
        }

        // Welcome START button handler
        const welcomeStartBtn = document.getElementById('welcome-start-btn');
        if (welcomeStartBtn) {
            welcomeStartBtn.addEventListener('click', () => {
                console.log('Welcome START button clicked');
                showGoalModal();
            });
        } else {
            console.error('Welcome START button not found!');
        }

        // Initialize app once JSON data is present
        function initializeApp() {
            if (!translation || !themeOptions || Object.keys(themeOptions).length === 0) {
                return;
            }

            const themeSelector = document.getElementById('theme-selector');
            if (!themeSelector) return;

            themeSelector.innerHTML = '';

            const nonAllTheme = Object.keys(themeOptions).find(key => key !== 'all');
            currentTheme = nonAllTheme ? parseInt(nonAllTheme, 10) : 'all';

            if (useThemeDropdown) {
                const wrapper = document.createElement('div');
                wrapper.className = 'theme-select-wrapper';
                const select = document.createElement('select');
                select.className = 'theme-select';

                Object.entries(themeOptions).forEach(([themeId, themeName]) => {
                    const option = document.createElement('option');
                    option.value = themeId;
                    option.textContent = themeName;
                    select.appendChild(option);
                });

                select.value = currentTheme === 'all' ? 'all' : String(currentTheme);
                select.addEventListener('change', (event) => {
                    if (!dataReady) return;
                    const value = event.target.value;
                    currentTheme = value === 'all' ? 'all' : parseInt(value, 10);
                    clearMatchingState();
                    updateSubtitle();
                    if (sessionActive) generateExercise();
                });

                wrapper.appendChild(select);
                themeSelector.appendChild(wrapper);
                themeSelectElement = select;
            } else {
                Object.entries(themeOptions).forEach(([themeId, themeName]) => {
                    const isActive = themeId === 'all'
                        ? currentTheme === 'all'
                        : currentTheme === parseInt(themeId, 10);

                    const button = document.createElement('button');
                    button.className = 'theme-btn' + (isActive ? ' active' : '');
                    button.dataset.theme = themeId;
                    button.textContent = themeName;
                    themeSelector.appendChild(button);
                });

                document.querySelectorAll('.theme-btn').forEach(btn => {
                    btn.addEventListener('click', () => {
                        if (!dataReady) return;
                        document.querySelectorAll('.theme-btn').forEach(b => b.classList.remove('active'));
                        btn.classList.add('active');
                        currentTheme = btn.dataset.theme === 'all' ? 'all' : parseInt(btn.dataset.theme, 10);
                        clearMatchingState();
                        updateSubtitle();
                        if (sessionActive) generateExercise();
                    });
                });
                themeSelectElement = null;
            }
        }

        // Exercise type selector
        document.querySelectorAll('.exercise-type-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.exercise-type-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                currentExerciseType = btn.dataset.type;
                if (currentExerciseType === 'matching') {
                    clearMatchingState();
                }
                if (dataReady && sessionActive) {
                    generateExercise();
                }
            });
        });

        // Change vocabulary button
        document.getElementById('change-vocab-btn')?.addEventListener('click', clearVocabularySelection);

        function shuffle(array) {
            const newArray = [...array];
            for (let i = newArray.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [newArray[i], newArray[j]] = [newArray[j], newArray[i]];
            }
            return newArray;
        }

        function getRandomItem(array) {
            return array[Math.floor(Math.random() * array.length)];
        }

        // Calculate similarity between two strings (Levenshtein distance based)
        function calculateSimilarity(str1, str2) {
            const s1 = str1.toLowerCase().trim();
            const s2 = str2.toLowerCase().trim();
            
            if (s1 === s2) return 100;
            
            const longer = s1.length > s2.length ? s1 : s2;
            const shorter = s1.length > s2.length ? s2 : s1;
            
            if (longer.length === 0) return 100;
            
            const editDistance = levenshteinDistance(s1, s2);
            const similarity = ((longer.length - editDistance) / longer.length) * 100;
            
            return similarity;
        }
        
        // Levenshtein distance algorithm
        function levenshteinDistance(str1, str2) {
            const matrix = [];
            
            for (let i = 0; i <= str2.length; i++) {
                matrix[i] = [i];
            }
            
            for (let j = 0; j <= str1.length; j++) {
                matrix[0][j] = j;
            }
            
            for (let i = 1; i <= str2.length; i++) {
                for (let j = 1; j <= str1.length; j++) {
                    if (str2.charAt(i - 1) === str1.charAt(j - 1)) {
                        matrix[i][j] = matrix[i - 1][j - 1];
                    } else {
                        matrix[i][j] = Math.min(
                            matrix[i - 1][j - 1] + 1,
                            matrix[i][j - 1] + 1,
                            matrix[i - 1][j] + 1
                        );
                    }
                }
            }
            
            return matrix[str2.length][str1.length];
        }

        function getStatLabel(key, fallback) {
            return translation?.stats?.[key] || fallback;
        }

        function updatePendingCounter() {
            const totalLabel = document.getElementById('total-label');
            const totalCountEl = document.getElementById('total-count');
            if (!totalLabel || !totalCountEl) return;

            if (sessionActive && sessionGoalType === 'exercises') {
                const remaining = Math.max(sessionGoalValue - totalCount, 0);
                totalLabel.textContent = getStatLabel('pending', 'Nog te doen');
                totalCountEl.textContent = remaining;
            } else {
                totalLabel.textContent = getStatLabel('total', 'Totaal');
                totalCountEl.textContent = totalCount;
            }
        }

        function updateScore() {
            document.getElementById('correct-count').textContent = correctCount;
            document.getElementById('incorrect-count').textContent = incorrectCount;
            updatePendingCounter();

            // Update progress bar using dedicated function
            updateProgressBar();

            // Check if goal reached
            checkSessionGoal();

            // Update compact stats line
            updateCompactTimer();
        }

        function createNextButton(text = `‚û°Ô∏è ${t('buttons.next')}`, handler = generateExercise) {
            const wrapper = document.createElement('div');
            wrapper.className = 'next-btn-wrapper';
            const button = document.createElement('button');
            button.className = 'next-btn';
            button.textContent = text;
            button.addEventListener('click', handler);
            wrapper.appendChild(button);
            return wrapper;
        }

        function generateMultipleChoice() {
            const vocabList = getCurrentVocabulary();
            const isWordToDefinition = Math.random() > 0.5;

            currentQuestion = getRandomItem(vocabList);

            const wrongAnswers = shuffle(vocabList.filter(v => v !== currentQuestion)).slice(0, 3);
            const allOptions = shuffle([currentQuestion, ...wrongAnswers]);

            const questionText = isWordToDefinition ? currentQuestion.word : currentQuestion.definition;
            const correctAnswer = isWordToDefinition ? currentQuestion.definition : currentQuestion.word;
            const questionLabel = isWordToDefinition ? t('questions.whatMeans') : t('questions.whichWord');

            // Start tracking time for this question
            exerciseStats['multiple-choice'].questionStartTime = Date.now();

            let html = `
                <div class="question">
                    <strong>${isWordToDefinition ? 'üìñ' : 'üîç'} ${questionLabel}</strong><br><br>
                    "${questionText}"
                </div>
                <div class="options">
            `;

            allOptions.forEach(option => {
                const optionText = isWordToDefinition ? option.definition : option.word;
                html += `<button class="option-btn" data-answer="${optionText}">${optionText}</button>`;
            });

            html += '</div>';

            document.getElementById('exercise-card').innerHTML = html;
            
            document.querySelectorAll('.option-btn').forEach(btn => {
                btn.addEventListener('click', function() {
                    if (this.classList.contains('disabled')) return;

                    document.querySelectorAll('.option-btn').forEach(b => b.classList.add('disabled'));

                    const isCorrect = this.dataset.answer === correctAnswer;
                    this.classList.add(isCorrect ? 'correct' : 'incorrect');

                    // Track time spent on this question
                    const timeSpent = Date.now() - exerciseStats['multiple-choice'].questionStartTime;
                    exerciseStats['multiple-choice'].totalTimeMs += timeSpent;
                    exerciseStats['multiple-choice'].total++;

                    if (isCorrect) {
                        correctCount++;
                        exerciseStats['multiple-choice'].correct++;
                    } else {
                        incorrectCount++;
                        exerciseStats['multiple-choice'].incorrect++;
                        document.querySelectorAll('.option-btn').forEach(b => {
                            if (b.dataset.answer === correctAnswer) {
                                b.classList.add('correct');
                            }
                        });
                    }

                    totalCount++;
                    updateScore();

                    const feedback = document.createElement('div');
                    feedback.className = `feedback ${isCorrect ? 'correct' : 'incorrect'}`;
                    feedback.textContent = isCorrect ? `üéâ ${t('feedback.correct')}` : `‚ùå ${t('feedback.incorrect')}`;
                    document.getElementById('exercise-card').appendChild(feedback);

                    // Auto-advance to next question after 2 seconds
                    if (sessionActive) {
                        setTimeout(() => {
                            if (sessionActive) {
                                generateExercise();
                            }
                        }, 2000);
                    }
                });
            });
        }

        function generateFillIn() {
            const vocabList = getCurrentVocabulary();
            const isWordToDefinition = Math.random() > 0.5;

            currentQuestion = getRandomItem(vocabList);

            const questionText = isWordToDefinition ? currentQuestion.word : currentQuestion.definition;
            const correctAnswer = isWordToDefinition ? currentQuestion.definition : currentQuestion.word;
            const questionLabel = isWordToDefinition ? t('questions.whatMeans') : t('questions.whichWord');

            // Start tracking time for this question
            exerciseStats['fill-in'].questionStartTime = Date.now();

            let html = `
                <div class="question">
                    <strong>${isWordToDefinition ? 'üìñ' : 'üîç'} ${questionLabel}</strong><br><br>
                    "${questionText}"
                </div>
                <input type="text" class="input-answer" id="answer-input" placeholder="${t('questions.typePlaceholder')}">
                <button class="submit-btn" id="submit-answer">${t('buttons.check')}</button>
            `;

            document.getElementById('exercise-card').innerHTML = html;

            document.getElementById('answer-input').focus();
            
            const submitAnswer = () => {
                const userAnswer = document.getElementById('answer-input').value.trim().toLowerCase();
                const correct = correctAnswer.toLowerCase();

                // Build list of all possible correct answers (main + alternatives)
                const allPossibleAnswers = [correctAnswer];

                // Only check alternatives when answering definition (word to definition mode)
                if (isWordToDefinition && currentQuestion.alternativeDefinitions && Array.isArray(currentQuestion.alternativeDefinitions)) {
                    allPossibleAnswers.push(...currentQuestion.alternativeDefinitions);
                }

                // Check exact match with any of the possible answers
                let isExactMatch = false;
                let bestMatchAnswer = correctAnswer;
                let bestSimilarity = 0;

                for (const possibleAnswer of allPossibleAnswers) {
                    const normalizedAnswer = possibleAnswer.toLowerCase().trim();

                    // Check for exact match
                    if (userAnswer === normalizedAnswer) {
                        isExactMatch = true;
                        bestMatchAnswer = possibleAnswer;
                        bestSimilarity = 100;
                        break;
                    }

                    // Calculate similarity
                    const similarity = calculateSimilarity(userAnswer, possibleAnswer);

                    // Keep track of best match
                    if (similarity > bestSimilarity) {
                        bestSimilarity = similarity;
                        bestMatchAnswer = possibleAnswer;
                    }
                }

                const isAlmostCorrect = bestSimilarity >= 80 && !isExactMatch;
                const isCorrect = isExactMatch || isAlmostCorrect;

                // Track time spent on this question
                const timeSpent = Date.now() - exerciseStats['fill-in'].questionStartTime;
                exerciseStats['fill-in'].totalTimeMs += timeSpent;
                exerciseStats['fill-in'].total++;

                if (isCorrect) {
                    correctCount++;
                    exerciseStats['fill-in'].correct++;
                } else {
                    incorrectCount++;
                    exerciseStats['fill-in'].incorrect++;
                }

                totalCount++;
                updateScore();

                const feedback = document.createElement('div');
                feedback.className = `feedback ${isCorrect ? 'correct' : 'incorrect'}`;
                const submittedAnswer = document.getElementById('answer-input').value.trim();

                if (isExactMatch) {
                    feedback.innerHTML = `üéâ ${t('feedback.correct')}`;
                } else if (isAlmostCorrect) {
                    feedback.innerHTML = `‚ú® ${t('feedback.almostCorrect', { percent: Math.round(bestSimilarity) })}<br><br>${t('feedback.yourAnswer')}: "${submittedAnswer}"<br>${t('feedback.correctAnswer')}: "${bestMatchAnswer}"`;
                } else {
                    feedback.innerHTML = `‚ùå ${t('feedback.theCorrectAnswerIs')}<br><br>"${correctAnswer}"`;
                }

                document.getElementById('exercise-card').appendChild(feedback);

                document.getElementById('submit-answer').remove();
                document.getElementById('answer-input').disabled = true;

                if (sessionActive) {
                    document.getElementById('exercise-card').appendChild(createNextButton());
                }
            };
            
            document.getElementById('submit-answer').addEventListener('click', submitAnswer);
            document.getElementById('answer-input').addEventListener('keypress', (e) => {
                if (e.key === 'Enter') submitAnswer();
            });
        }

        function initializeMatchingPool() {
            const vocabList = getCurrentVocabulary();
            const shuffled = shuffle(vocabList);
            const activeSize = Math.min(MATCHING_ACTIVE_SIZE, shuffled.length);
            activeMatches = shuffled.slice(0, activeSize);
            matchingPool = shuffled.slice(activeSize);
        }

        function renderMatchingBoard() {
            const card = document.getElementById('exercise-card');
            if (!card || !sessionActive) return;

            if (!activeMatches.length) {
                card.innerHTML = '';
                const feedback = document.createElement('div');
                feedback.className = 'feedback correct';
                feedback.textContent = `üéâ ${t('feedback.allMatched')}`;
                card.appendChild(feedback);

                const nextWrapper = createNextButton(`‚û°Ô∏è ${t('buttons.nextExercise')}`, () => {
                    clearMatchingState();
                    generateExercise();
                });
                card.appendChild(nextWrapper);
                return;
            }

            const words = shuffle(activeMatches.map(item => ({ text: item.word, id: item.word })));
            const definitions = shuffle(activeMatches.map(item => ({ text: item.definition, id: item.word })));

            let html = `
                <div class="question">
                    <strong>üîó ${t('questions.matchWords')}</strong><br>
                    <small>${t('questions.matchInstructions')}</small>
                </div>
                <div class="matching-container">
                    <div class="matching-column" id="words-column">
            `;

            words.forEach(item => {
                html += `<div class="matching-item" data-id="${item.id}" data-side="word">${item.text}</div>`;
            });

            html += `
                    </div>
                    <div class="matching-column" id="definitions-column">
            `;

            definitions.forEach(item => {
                html += `<div class="matching-item" data-id="${item.id}" data-side="definition">${item.text}</div>`;
            });

            html += `
                    </div>
                </div>
                <div id="matching-feedback"></div>
            `;

            card.innerHTML = html;
            matchingSelections = [];
            matchingLocked = false;

            document.querySelectorAll('.matching-item').forEach(item => {
                item.addEventListener('click', () => handleMatchingSelection(item));
            });

            // Normalize item heights to the tallest to avoid layout shift on hover
            scheduleNormalizeMatchingHeights();
        }

        function normalizeMatchingHeights() {
            const container = document.querySelector('.matching-container');
            if (!container) return;
            const items = Array.from(container.querySelectorAll('.matching-item'));
            if (!items.length) return;
            // reset
            items.forEach(el => { el.style.height = 'auto'; });
            let max = 0;
            items.forEach(el => { max = Math.max(max, el.getBoundingClientRect().height); });
            const h = Math.ceil(max);
            items.forEach(el => { el.style.height = h + 'px'; });
        }

        let normalizeMatchingHeightsRAF = 0;
        function scheduleNormalizeMatchingHeights() {
            if (normalizeMatchingHeightsRAF) cancelAnimationFrame(normalizeMatchingHeightsRAF);
            normalizeMatchingHeightsRAF = requestAnimationFrame(() => {
                normalizeMatchingHeightsRAF = 0;
                normalizeMatchingHeights();
            });
        }

        function handleMatchingSelection(element) {
            if (matchingLocked) return;

            if (element.classList.contains('selected')) {
                element.classList.remove('selected');
                matchingSelections = matchingSelections.filter(sel => sel.element !== element);
                return;
            }

            if (matchingSelections.length === 1 && matchingSelections[0].side === element.dataset.side) {
                matchingSelections[0].element.classList.remove('selected');
                matchingSelections = [];
            }

            element.classList.add('selected');
            matchingSelections.push({
                element,
                id: element.dataset.id,
                side: element.dataset.side
            });

            // Start tracking time when first selection is made
            if (matchingSelections.length === 1) {
                exerciseStats['matching'].questionStartTime = Date.now();
            }

            if (matchingSelections.length === 2) {
                const [first, second] = matchingSelections;
                if (first.side === second.side) {
                    first.element.classList.remove('selected');
                    matchingSelections = [second];
                    // Restart timer since we're starting over
                    exerciseStats['matching'].questionStartTime = Date.now();
                    return;
                }

                matchingLocked = true;
                processMatchingAttempt(first, second);
            }
        }

        function processMatchingAttempt(first, second) {
            const wordSelection = first.side === 'word' ? first : second;
            const definitionSelection = first.side === 'definition' ? first : second;
            const isCorrect = wordSelection.id === definitionSelection.id;
            const matchedEntry = activeMatches.find(item => item.word === wordSelection.id);

            // Track time spent on this matching attempt
            const timeSpent = Date.now() - exerciseStats['matching'].questionStartTime;
            exerciseStats['matching'].totalTimeMs += timeSpent;
            exerciseStats['matching'].total++;

            if (isCorrect) {
                correctCount++;
                exerciseStats['matching'].correct++;
            } else {
                incorrectCount++;
                exerciseStats['matching'].incorrect++;
            }

            totalCount++;
            updateScore();

            const feedbackContainer = document.getElementById('matching-feedback');
            if (feedbackContainer) {
                feedbackContainer.innerHTML = '';
                const feedback = document.createElement('div');
                feedback.className = `feedback ${isCorrect ? 'correct' : 'incorrect'}`;
                if (isCorrect) {
                    feedback.textContent = `üéâ ${t('feedback.correct')}`;
                } else {
                    feedback.innerHTML = `‚ùå ${t('feedback.theCorrectAnswerIs')}<br>"${matchedEntry?.definition || ''}"`;
                }
                feedbackContainer.appendChild(feedback);
            }

            first.element.classList.add(isCorrect ? 'matched' : 'incorrect');
            second.element.classList.add(isCorrect ? 'matched' : 'incorrect');

            matchingSelections = [];

            setTimeout(() => {
                if (feedbackContainer) {
                    feedbackContainer.innerHTML = '';
                }

                if (isCorrect) {
                    activeMatches = activeMatches.filter(item => item.word !== wordSelection.id);
                    if (matchingPool.length) {
                        activeMatches.push(matchingPool.shift());
                    }
                }

                matchingLocked = false;
                if (sessionActive) {
                    renderMatchingBoard();
                }
            }, isCorrect ? 900 : 800);
        }

        function generateMatching(resetPool = false) {
            if (!sessionActive) return;
            const vocabList = getCurrentVocabulary();
            if (!vocabList.length) {
                document.getElementById('exercise-card').innerHTML = '<p style="text-align:center;">Geen woorden beschikbaar voor deze selectie.</p>';
                return;
            }

            if (resetPool || activeMatches.length === 0) {
                initializeMatchingPool();
            }

            renderMatchingBoard();
        }

        function generateTrueFalse() {
            const vocabList = getCurrentVocabulary();
            currentQuestion = getRandomItem(vocabList);

            const isCorrectStatement = Math.random() > 0.5;
            let displayDefinition;

            if (isCorrectStatement) {
                displayDefinition = currentQuestion.definition;
            } else {
                const wrongItem = getRandomItem(vocabList.filter(v => v !== currentQuestion));
                displayDefinition = wrongItem.definition;
            }

            const questionTitle = t('questions.trueFalseQuestion');
            const trueLabel = t('buttons.true');
            const falseLabel = t('buttons.false');

            // Start tracking time for this question
            exerciseStats['true-false'].questionStartTime = Date.now();

            let html = `
                <div class="question">
                    <strong>‚úì / ‚úó ${questionTitle}</strong><br><br>
                    <strong>"${currentQuestion.word}"</strong> ${t('questions.whatMeans')}<br><br>
                    "${displayDefinition}"
                </div>
                <div class="true-false-btns">
                    <button class="tf-btn true" data-answer="true">‚úì ${trueLabel}</button>
                    <button class="tf-btn false" data-answer="false">‚úó ${falseLabel}</button>
                </div>
            `;

            document.getElementById('exercise-card').innerHTML = html;
            
            document.querySelectorAll('.tf-btn').forEach(btn => {
                btn.addEventListener('click', function() {
                    const userAnswerTrue = this.dataset.answer === 'true';
                    const isCorrect = userAnswerTrue === isCorrectStatement;

                    // Track time spent on this question
                    const timeSpent = Date.now() - exerciseStats['true-false'].questionStartTime;
                    exerciseStats['true-false'].totalTimeMs += timeSpent;
                    exerciseStats['true-false'].total++;

                    if (isCorrect) {
                        correctCount++;
                        exerciseStats['true-false'].correct++;
                    } else {
                        incorrectCount++;
                        exerciseStats['true-false'].incorrect++;
                    }

                    totalCount++;
                    updateScore();
                    
                    const feedback = document.createElement('div');
                    feedback.className = `feedback ${isCorrect ? 'correct' : 'incorrect'}`;
                    
                    if (isCorrect) {
                        feedback.textContent = `üéâ ${t('feedback.correct')}`;
                    } else {
                        const correctAnswerText = isCorrectStatement ? trueLabel : falseLabel;
                        feedback.innerHTML = `‚ùå ${t('feedback.theCorrectAnswerIs')} ${correctAnswerText}<br><br>${t('feedback.correctAnswer')}:<br>"${currentQuestion.definition}"`;
                    }
                    
                    document.getElementById('exercise-card').appendChild(feedback);
                    
                    document.querySelectorAll('.tf-btn').forEach(b => b.style.display = 'none');
                    
                    if (sessionActive) {
                        document.getElementById('exercise-card').appendChild(createNextButton());
                    }
                });
            });
        }

        function generateExercise() {
            if (!sessionActive) return; // Do not generate when session ended; keep results visible
            switch(currentExerciseType) {
                case 'multiple-choice':
                    generateMultipleChoice();
                    break;
                case 'fill-in':
                    generateFillIn();
                    break;
                case 'matching':
                    generateMatching();
                    break;
                case 'true-false':
                    generateTrueFalse();
                    break;
            }
        }

        // Don't initialize exercise at page load - wait for START button
        // generateExercise();

        // Fetch vocabulary and translations once the page loads
        loadData();

        // Sticky header: compact on scroll
        function updateHeaderCompactState() {
            const header = document.getElementById('app-header');
            if (!header) return;
            const scrolled = window.scrollY > 40;
            if (scrolled) {
                header.classList.add('compact');
            } else {
                header.classList.remove('compact');
            }
        }

        window.addEventListener('scroll', updateHeaderCompactState, { passive: true });
        document.addEventListener('DOMContentLoaded', updateHeaderCompactState);
        window.addEventListener('resize', () => {
            scheduleNormalizeMatchingHeights();
        }, { passive: true });
    </script>
</body>
</html>
